[{"/Users/makskornakov/Desktop/someHook/canvas-trading/src/index.tsx":"1","/Users/makskornakov/Desktop/someHook/canvas-trading/src/reportWebVitals.ts":"2","/Users/makskornakov/Desktop/someHook/canvas-trading/src/App.tsx":"3","/Users/makskornakov/Desktop/someHook/canvas-trading/src/Canvas.tsx":"4","/Users/makskornakov/Desktop/someHook/canvas-trading/src/draw.ts":"5"},{"size":554,"mtime":1669395235809,"results":"6","hashOfConfig":"7"},{"size":425,"mtime":1669395061256,"results":"8","hashOfConfig":"7"},{"size":514,"mtime":1669411820001,"results":"9","hashOfConfig":"7"},{"size":711,"mtime":1669409608274,"results":"10","hashOfConfig":"7"},{"size":2800,"mtime":1669411645339,"results":"11","hashOfConfig":"7"},{"filePath":"12","messages":"13","suppressedMessages":"14","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"15"},"1vnkbno",{"filePath":"16","messages":"17","suppressedMessages":"18","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"15"},{"filePath":"19","messages":"20","suppressedMessages":"21","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"22","messages":"23","suppressedMessages":"24","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"25","messages":"26","suppressedMessages":"27","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"28","usedDeprecatedRules":"29"},"/Users/makskornakov/Desktop/someHook/canvas-trading/src/index.tsx",[],[],[],"/Users/makskornakov/Desktop/someHook/canvas-trading/src/reportWebVitals.ts",[],[],"/Users/makskornakov/Desktop/someHook/canvas-trading/src/App.tsx",[],[],"/Users/makskornakov/Desktop/someHook/canvas-trading/src/Canvas.tsx",[],[],"/Users/makskornakov/Desktop/someHook/canvas-trading/src/draw.ts",["30"],[],"export const drawFunction = (ctx: CanvasRenderingContext2D) => {\n  ctx.fillStyle = 'red';\n  ctx.fillRect(0, 0, 100, 100);\n};\n\ninterface candleToDraw {\n  open: number;\n  high: number;\n  low: number;\n  close: number;\n  indicators: {\n    revBar: 'buy' | 'sell';\n    fractal: 'up' | 'down';\n    alligator: {\n      jaw: number;\n      teeth: number;\n      lips: number;\n    };\n  };\n}\nclass CandleCanvas {\n  width: number;\n  height: number;\n  candlesShown: number;\n  candlesToDraw: candleToDraw[] = [];\n  min: number;\n  max: number;\n  gap: number;\n  candleWidth: number;\n\n  constructor(\n    width: number,\n    height: number,\n    candlesShown: number,\n    candlesToDraw: candleToDraw[]\n  ) {\n    this.width = width;\n    this.height = height;\n    this.candlesShown = candlesShown;\n\n    const minMax = this.minMaxCalc(candlesToDraw);\n    this.min = minMax.min;\n    this.max = minMax.max;\n\n    const gapAndWidth = this.getGapAndCandleWidth();\n    this.gap = gapAndWidth.gap;\n    this.candleWidth = gapAndWidth.candleWidth;\n  }\n  private getGapAndCandleWidth() {\n    const gap = this.width / this.candlesShown / 10;\n    const candleWidth = (this.width / this.candlesShown - gap) / 2;\n    return { gap, candleWidth };\n  }\n  private minMaxCalc(candles: candleToDraw[]) {\n    const min = Math.min(...candles.map((candle) => candle.low));\n    const max = Math.max(...candles.map((candle) => candle.high));\n    return { min, max };\n  }\n}\n\ninterface CandleMountPoints {\n  above: {\n    first: number;\n    second: number;\n  };\n  below: {\n    first: number;\n    second: number;\n  };\n}\n\nclass Candle2D {\n  open: number;\n  close: number;\n  low: number;\n  high: number;\n  mountPoints: CandleMountPoints;\n\n  constructor(\n    originalOpen: number,\n    originalClose: number,\n    originalLow: number,\n    originalHigh: number,\n    candleCanvas: CandleCanvas\n  ) {\n    this.open = this.getPoint(originalOpen, candleCanvas);\n    this.close = this.getPoint(originalClose, candleCanvas);\n    this.low = this.getPoint(originalLow, candleCanvas);\n    this.high = this.getPoint(originalHigh, candleCanvas);\n    this.mountPoints = this.getMountPoints(candleCanvas);\n  }\n  // private arrow function with original point as an argument\n  private getPoint = (originalPoint: number, candleCanvas: CandleCanvas) => {\n    const point =\n      ((candleCanvas.max - originalPoint) /\n        (candleCanvas.max - candleCanvas.min)) *\n      candleCanvas.height;\n    return point;\n  };\n\n  private getMountPoints(candleCanvas: CandleCanvas): CandleMountPoints {\n    const yGap = candleCanvas.candleWidth * 1.5;\n    const above = {\n      first: this.high + yGap,\n      second: this.high + yGap * 3,\n    };\n    const below = {\n      first: this.low - yGap,\n      second: this.low - yGap * 3,\n    };\n    return {\n      above,\n      below,\n    };\n  }\n}\n",[],{"ruleId":"31","severity":1,"message":"32","line":72,"column":7,"nodeType":"33","messageId":"34","endLine":72,"endColumn":15},"@typescript-eslint/no-unused-vars","'Candle2D' is defined but never used.","Identifier","unusedVar"]